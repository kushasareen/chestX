# -*- coding: utf-8 -*-
"""Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V2mG_Deo_vCtVwKYlnd0ejDCl4e0XcnH

Importing libraries.
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import os
from glob import glob
# %matplotlib inline
import matplotlib.pyplot as plt

"""Using Kaggle API to load the dataset."""

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/kaggle.json
!chmod 600 /root/.kaggle/kaggle.json

!kaggle datasets download -d nih-chest-xrays/data

"""Unzipping the data..."""

!unzip /content/data.zip

"""Print some sample images from the dataset:"""

from IPython.display import display, Image
import glob


sample_images = glob.glob('./images_001/images/*.png')[:5]
for file_path in sample_images:
  display(Image(file_path))

"""Now we load the images into a list in greyscale."""

from pathlib import Path
import cv2
from IPython.display import display, Image
import glob


image_paths = list(Path('.').rglob('./*.png'))

from PIL import Image

for path in image_paths: 
  Image.open(path).resize((50,50)).save(path)

images = np.stack([cv2.imread(str(x), cv2.IMREAD_GRAYSCALE) 
                   for x in image_paths])

print('Original Image Shape (N, H, W):', images.shape)

"""Loading the patient characteristics and labels from a csv."""

# data = pd.read_csv('https://raw.githubusercontent.com/kushasareen/chest_x-rays/master/data_entry')

labels = np.array(pd.read_csv('https://raw.githubusercontent.com/kushasareen/chest_x-rays/master/data_entry').iloc[:,1])[:len(image_paths)]
age = np.array(pd.read_csv('https://raw.githubusercontent.com/kushasareen/chest_x-rays/master/data_entry').iloc[:,4])[:len(image_paths)]
sex = np.array(pd.read_csv('https://raw.githubusercontent.com/kushasareen/chest_x-rays/master/data_entry').iloc[:,5])[:len(image_paths)]

print('Num Labels:', len(labels))
print(age[0])
print(sex[0])
print(labels[0])

images = images[:112120]
images = images[labels != "No Finding"]
images.shape

sex = sex[labels != "No Finding"]
age = age[labels != "No Finding"]
labels = labels[labels != "No Finding"]

len(labels)

"""We do the same with the bounding box data."""

bounding_boxes = pd.read_csv('https://raw.githubusercontent.com/kushasareen/chest_x-rays/master/BBox_List_2017.csv')

bounding_boxes['y']

"""Next, we want to preprocess the csv data to be able to feed into our model. Again, this is something we do with a series of methods."""

from sklearn.preprocessing import MultiLabelBinarizer

split_labels = []

for label in labels:
  split_labels.append(str(label).split('|'))

len(split_labels)

mlb = MultiLabelBinarizer()

split_labels = mlb.fit_transform(split_labels)

split_labels

"""We want to feed the model a second image of just the bounding box if one is present and populate the rest of the non-bounding box pixels with -1s. We do this in a method in order to be able to reuse in the web app. I'm not sure how to do this yet."""

scale_factor = 1024 / 50

bb_x = bounding_boxes['Bbox [x'] / scale_factor
bb_y = bounding_boxes['y'] / scale_factor
bb_w = bounding_boxes['w'] / scale_factor
bb_h = bounding_boxes['h]'] / scale_factor

bb_matrix = np.full((len(images), 50, 50), -255)

images[0][2:4,2:4]

import os

for i in range(len(image_paths)):
  if (os.path.basename(image_paths[i]) in bounding_boxes['Image Index']):
    bb_matrix[i][int(bb_x): int(bb_x + bb_w) ,int(bb_y): int(bb_y + bb_h)] = images[i][int(bb_x): int(bb_x + bb_w) ,int(bb_y): int(bb_y + bb_h)]

bb_matrix

"""Normalizing the image data:"""

images = np.expand_dims(images / 255, axis=-1) #change this to images, we're using double the RAM necessary
images.shape

bb_matrix = np.expand_dims(bb_matrix / 255, axis=-1) #change this to bb_matrix
bb_matrix.shape

images

"""Now, we can split the data into training, testing and validation sets."""

age = age / 100
age

sex[sex == 'M'] = 0
sex[sex == 'F'] = 1

sex

labels.shape

from sklearn.model_selection import train_test_split #maybe needs some work

train_images, valid_images, train_labels, valid_labels = train_test_split(images[:112120], split_labels, test_size=0.1, random_state=456)
train_bb, valid_bb = train_test_split(bb_matrix, test_size=0.1, random_state=456)
train_patchars, valid_patchars = train_test_split(tuple(zip(age, sex)), test_size=0.1, random_state=456)



"""Finally, we can begin to build a structure for the model."""

import keras 
from keras.layers.core import Dense, Dropout, Activation, Flatten
from keras.layers.convolutional import Conv2D, MaxPooling2D, SeparableConv2D
from keras.regularizers import l2
from keras.optimizers import SGD, RMSprop
from keras.utils import to_categorical
from keras.layers.normalization import BatchNormalization
from keras.utils.vis_utils import plot_model
from keras.layers import Input, GlobalAveragePooling2D, Concatenate
from keras import models
from keras.models import Model

# define three sets of inputs
inputA = Input(shape=(2,)) # age and sex
inputB = Input(shape=(50, 50, 1)) # x-ray
inputC = Input(shape=(50, 50, 1)) # bounding box
 
# the first branch operates on patient age and sex
x = Dense(32, activation="relu")(inputA)
x = Dropout(0.2)(x)
x = Dense(128, activation="relu")(x)
x = Model(inputs=inputA, outputs=x)
 
# the second branch opreates on the chest x-ray (inception network)

y_1 = Conv2D(10, (1,1), padding='same', activation='relu')(inputB)
y_1 = Conv2D(10, (3,3), padding='same', activation='relu')(y_1)

y_2 = Conv2D(10, (1,1), padding='same', activation='relu')(inputB)
y_2 = Conv2D(10, (5,5), padding='same', activation='relu')(y_2)

y_3 = MaxPooling2D((3,3), strides=(1,1), padding='same')(inputB)
y_3 = Conv2D(10, (1,1), padding='same', activation='relu')(y_3)

y_combined = Concatenate()([y_1, y_2, y_3])

y_flat = Flatten()(y_combined)
y_dense = Dense(128, activation="relu")(y_flat)

y = Model(inputs=inputB, outputs=y_dense)

 # the third branch opreates on the bounding box data

z = Conv2D(10, (3,3), padding='same', activation='relu')(inputC)
z = MaxPooling2D((3,3), strides=(1,1), padding='same')(z)
z = Flatten()(z)
z = Dense(128, activation="relu")(z)

z = Model(inputs=inputC, outputs=z)

# combine the output of the three branches
combined = Concatenate()([x.output, y.output, z.output])
 
# predic final classification with a multi-label binary classifier
out = Dense(64, activation="relu")(combined)
out = Dropout(0.2)(out)
out = Dense(32, activation="relu")(out)
out = Dropout(0.2)(out)
out = Dense(14, activation="sigmoid")(out)

model = Model(inputs=[x.input, y.input, z.input], outputs=out)

"""A model summary:"""

model.summary()
plot_model(model, to_file='model.png', show_shapes=True, show_layer_names=True)

"""Compiling..."""

model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['acc'])

# preds = model.predict(X_test)
# preds[preds>=0.5] = 1
# preds[preds<0.5] = 0
# score = compare preds and y_test

"""Training and evaluating the model:"""

from keras.utils import to_categorical

model.fit(
	[train_patchars, train_images, train_bb], train_labels,
	validation_data=([valid_patchars, valid_images, valid_bb], valid_labels),
	epochs=5, batch_size=128)

"""Finally, now that we have a trained model, we want to write a function that will take input a given chest x-ray, age, sex and potentially a bounding box and output a classification."""

model.save('chest_x-ray.h5')

model.save_weights('model_weights.h5')

from sklearn.metrics import multilabel_confusion_matrix


y_pred = model.predict([valid_patchars, valid_images, valid_bb])
y_pred = (y_pred > 0.5) #this needs work


multilabel_confusion_matrix(valid_labels, y_pred)